import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib as mpl
import matplotlib.pyplot as plt
import matplotlib.patches as mpatches
import wget
import folium
from folium.plugins import MarkerCluster
from PIL import Image
from wordcloud import WordCloud, STOPWORDS

# Show all available colors
# for name, hex in matplotlib.colors.cnames.items():
#    print(name, hex)

mpl.style.use('ggplot')

df_canada = pd.read_excel('https://s3-api.us-geo.objectstorage.softlayer.net/cf-courses-data/CognitiveClass/DV0101EN/labs/Data_Files/Canada.xlsx',
                          sheet_name='Canada by Citizenship',
                          skiprows=range(20),
                          skipfooter=2)

print(df_canada.head())

# Use country as index
df_canada.rename(columns={"OdName": "Country"}, inplace=True)
df_canada.set_index('Country', inplace=True)

# Create sum of total immigrants
# Get all years columns and sum on the horizontal
years = df_canada.columns[8:]
total = df_canada.loc[:, years].sum(axis=1, skipna=True)
df_canada['Total'] = total

# Creating line plots


def linePlots(df_canada, years):
    df_canada.loc['Haiti', years].plot(kind='line')
    plt.title('Immigration from Haiti')
    plt.ylabel('Number of immigrants')
    plt.xlabel('Years')
    plt.show()

# Area plots


def areaPlots(df_canada):
    df_canada.sort_values(['Total'], ascending=False, axis=0, inplace=True)
    df_top5 = df_canada.head()
    df_top5 = df_top5[years].transpose()

    df_top5.plot(kind='area', stacked=True)
    plt.title('Immigration trend of top 5 countries')
    plt.ylabel('Number of immigrants')
    plt.xlabel('Years')
    plt.show()

# Histograms


def histogramPlots(df_canada):
    count, bin_edges = np.histogram(df_canada[2013])
    df_canada[2013].plot(kind='hist', xticks=bin_edges)
    plt.title('Histogram of Immigration from 195 countries in 2013')
    plt.xlabel('Number of Immigrants')
    plt.ylabel('Number of Countries')
    plt.show()

# Bar chart


def barChart(df_canada, years):
    df_iceland = df_canada.loc['Iceland', years]

    df_iceland.plot(kind='bar')
    plt.title('Icelandic immigrants to Canada from 1980 to 2013')
    plt.ylabel('Number of immigrants')
    plt.xlabel('Year')

    # Annotate arrow
    plt.annotate('',                      # s: str. Will leave it blank for no text
                 # place head of the arrow at point (year 2012 , pop 70)
                 xy=(32, 70),
                 # place base of the arrow at point (year 2008 , pop 20)
                 xytext=(28, 20),
                 xycoords='data',         # will use the coordinate system of the object being annotated
                 arrowprops=dict(arrowstyle='->',
                                 connectionstyle='arc3', color='blue', lw=2)
                 )

    # Annotate Text
    plt.annotate('2008 - 2011 Financial Crisis',  # text to display
                 # start the text at at point (year 2008 , pop 30)
                 xy=(28, 30),
                 rotation=77,                  # based on trial and error to match the arrow
                 va='bottom',                    # want the text to be vertically 'bottom' aligned
                 # want the text to be horizontally 'left' algned.
                 ha='left',
                 )
    plt.show()

# Pie charts


def pieChart(df_canada):
    # Group by continent
    df_continents = df_canada.groupby('AreaName', axis=0).sum()

    colors_list = ['gold', 'yellowgreen', 'lightcoral',
                   'lightskyblue', 'lightgreen', 'pink']
    # ratio for each continent with which to offset each wedge.
    explode_list = [0.1, 0, 0, 0, 0.1, 0.1]

    df_continents['Total'].plot(kind='pie',
                                figsize=(15, 6),
                                autopct='%1.1f%%',
                                startangle=90,
                                shadow=True,
                                labels=None,         # turn off labels on pie chart
                                # the ratio between the center of each pie slice and the start of the text generated by autopct
                                pctdistance=1.12,
                                colors=colors_list,  # add custom colors
                                explode=explode_list  # 'explode' lowest 3 continents
                                )

    # scale the title up by 12% to match pctdistance
    plt.title('Immigration to Canada by Continent [1980 - 2013]', y=1.12)

    plt.axis('equal')

    # add legend
    plt.legend(labels=df_continents.index, loc='upper left')
    plt.show()

# Box plot


def boxPlots(df_canada, years):
    df_japan = df_canada.loc['Japan', years].transpose()
    df_japan.plot(kind='box')
    plt.title('Box plot of Japanese Immigrants from 1980-2013')
    plt.ylabel('Number of Immigrants')

    df_CI = df_canada.loc[['China', 'India'], years].transpose()
    df_CI.plot(kind='box')
    plt.title('Box plot of Chinese and Indian Immigrants from 1980-2013')
    plt.ylabel('Number of Immigrants')
    plt.show()

    # Subplots
    fig = plt.figure()  # create figure

    # add subplot 1 (1 row, 2 columns, first plot)
    ax0 = fig.add_subplot(1, 2, 1)
    # add subplot 2 (1 row, 2 columns, second plot). See tip below**
    ax1 = fig.add_subplot(1, 2, 2)

    # Subplot 1: Box plot
    df_CI.plot(kind='box', figsize=(20, 6), ax=ax0)  # add to subplot 1
    ax0.set_title('Box Plots of Immigrants from China and India (1980 - 2013)')
    ax0.set_xlabel('Number of Immigrants')
    ax0.set_ylabel('Countries')

    # Subplot 2: Line plot
    df_CI.plot(kind='line', figsize=(20, 6), ax=ax1)  # add to subplot 2
    ax1.set_title(
        'Line Plots of Immigrants from China and India (1980 - 2013)')
    ax1.set_ylabel('Number of Immigrants')
    ax1.set_xlabel('Years')
    plt.show()

    df_top15 = df_canada.head(15)
    decades = [list(range(1980, 1990)), list(
        range(1990, 2000)), list(range(2000, 2014))]
    decArray = np.array([df_top15.loc[:, decades[0]].sum(axis=1).tolist(),
                         df_top15.loc[:, decades[1]].sum(axis=1).tolist(),
                         df_top15.loc[:, decades[2]].sum(axis=1).tolist()]).transpose()

    # or new_df = pd.DataFrame({'80s': df_80s, '90s': df_90s, '00s':df_00s})

    new_df = pd.DataFrame(decArray,
                          index=df_top15.index,
                          columns=['80s', '90s', '00s'])
    new_df.plot(kind='box')
    plt.title('Box plot of top 15 countries immigration grouped by decades')
    plt.xlabel('Decades')
    plt.ylabel('Number of Immigrants')
    plt.show()

# Scatter plot


def scatterPlots(df_canada, years):
    data = df_canada.loc[:, years].sum(axis=0).tolist()

    dataArray = np.array([list(years), data]).transpose()
    df_total = pd.DataFrame(dataArray,
                            columns=['Years', 'Total'])

    df_total.plot(
        kind='scatter',
        x='Years',
        y='Total'
    )

    plt.title('Total Immigrant population to Canada from 1980-2013')
    plt.xlabel('Years')
    plt.ylabel('Number of Immigrants')
    plt.show()

    # we can use the sum() method to get the total population per year
    df_tot = pd.DataFrame(df_canada[years].sum(axis=0))
    # change the years to type int (useful for regression later on)
    df_tot.index = map(int, df_tot.index)
    # reset the index to put in back in as a column in the df_tot dataframe
    df_tot.reset_index(inplace=True)
    # rename columns
    df_tot.columns = ['year', 'total']

    x = df_tot['year']      # year on x-axis
    y = df_tot['total']     # total on y-axis
    fit = np.polyfit(x, y, deg=1)

    df_tot.plot(kind='scatter', x='year', y='total',
                figsize=(10, 6), color='darkblue')

    plt.title('Total Immigration to Canada from 1980 - 2013')
    plt.xlabel('Year')
    plt.ylabel('Number of Immigrants')

    # plot line of best fit
    plt.plot(x, fit[0] * x + fit[1], color='red')  # recall that x is the Years
    plt.annotate(
        'y={0:.0f} x + {1:.0f}'.format(fit[0], fit[1]), xy=(2000, 150000))
    plt.show()

# Regression plots with seaborn


def regressionPlots(df_canada, years):
    # we can use the sum() method to get the total population per year
    df_tot = pd.DataFrame(df_canada[years].sum(axis=0))
    # change the years to type int (useful for regression later on)
    df_tot.index = map(int, df_tot.index)
    # reset the index to put in back in as a column in the df_tot dataframe
    df_tot.reset_index(inplace=True)
    # rename columns
    df_tot.columns = ['year', 'total']
    sns.regplot(x='year', y='total', data=df_tot, color='blue')
    plt.show()

# Bubble plots


def bubblePlots(df_canada):
    df_can_t = df_canada.drop(columns=df_canada.columns[:8]).transpose()
    df_can_t.drop(index='Total', inplace=True)
    df_can_t.index.name = 'Year'
    df_can_t.reset_index(inplace=True)
    # normalize Brazil data
    norm_brazil = (df_can_t['Brazil'] - df_can_t['Brazil'].min()) / \
        (df_can_t['Brazil'].max() - df_can_t['Brazil'].min())

    # normalize Argentina data
    norm_argentina = (df_can_t['Argentina'] - df_can_t['Argentina'].min()) / \
        (df_can_t['Argentina'].max() - df_can_t['Argentina'].min())

    # Brazil
    ax0 = df_can_t.plot(kind='scatter',
                        x='Year',
                        y='Brazil',
                        figsize=(14, 8),
                        alpha=0.5,                  # transparency
                        color='green',
                        s=norm_brazil * 2000 + 10,  # pass in weights
                        xlim=(1975, 2015)
                        )

    # Argentina
    df_can_t.plot(kind='scatter',
                  x='Year',
                  y='Argentina',
                  alpha=0.5,
                  color="blue",
                  s=norm_argentina * 2000 + 10,
                  ax=ax0
                  )

    ax0.set_ylabel('Number of Immigrants')
    ax0.set_title('Immigration from Brazil and Argentina from 1980 - 2013')
    ax0.legend(['Brazil', 'Argentina'], loc='upper left', fontsize='x-large')
    plt.show()

# Waffle chart


def waffleChart(df_canada, use_fun):
    df_dsn = df_canada.loc[['Denmark', 'Norway', 'Sweden'], :]
    print(df_dsn.head())

    width = 40  # width of chart
    height = 10  # height of chart

    categories = df_dsn.index.values  # categories
    values = df_dsn['Total']  # corresponding values of categories

    colormap = plt.cm.coolwarm  # color map class
    create_waffle_chart(categories, values, height, width, colormap)

    if(use_fun == True):
        return

    # 1 - determine the proportion of each category
    # compute the proportion of each category with respect to the total
    total_values = sum(df_dsn['Total'])
    category_proportions = [(float(value) / total_values)
                            for value in df_dsn['Total']]
    # print out proportions
    for i, proportion in enumerate(category_proportions):
        print(df_dsn.index.values[i] + ': ' + str(proportion))

    # 2 - Define total size of the chart
    width = 40  # width of chart
    height = 10  # height of chart
    total_num_tiles = width * height  # total number of tiles
    print('Total number of tiles is ', total_num_tiles)

    # 3 - determine number of tiles
    # compute the number of tiles for each category
    tiles_per_category = [round(proportion * total_num_tiles)
                          for proportion in category_proportions]

    # print out number of tiles per category
    for i, tiles in enumerate(tiles_per_category):
        print(df_dsn.index.values[i] + ': ' + str(tiles))

    # 4 - create matrix for the chart
    # initialize the waffle chart as an empty matrix
    waffle_chart = np.zeros((height, width))

    # define indices to loop through waffle chart
    category_index = 0
    tile_index = 0

    # populate the waffle chart
    for col in range(width):
        for row in range(height):
            tile_index += 1

            # if the number of tiles populated for the current category is equal to its corresponding allocated tiles...
            if tile_index > sum(tiles_per_category[0:category_index]):
                # ...proceed to the next category
                category_index += 1

            # set the class value to an integer, which increases with class
            waffle_chart[row, col] = category_index

    print('Waffle chart populated!')

    # 5 - map the matrix to a visual
    # use matshow to display the waffle chart
    colormap = plt.cm.coolwarm
    plt.matshow(waffle_chart, cmap=colormap)
    plt.colorbar()

    # 6 - prettify the chart
    # get the axis
    ax = plt.gca()

    # set minor ticks
    ax.set_xticks(np.arange(-.5, (width), 1), minor=True)
    ax.set_yticks(np.arange(-.5, (height), 1), minor=True)

    # add gridlines based on minor ticks
    ax.grid(which='minor', color='w', linestyle='-', linewidth=2)

    plt.xticks([])
    plt.yticks([])

    # 7 - create a legend
    # compute cumulative sum of individual categories to match color schemes between chart and legend
    values_cumsum = np.cumsum(df_dsn['Total'])
    total_values = values_cumsum[len(values_cumsum) - 1]

    # create legend
    legend_handles = []
    for i, category in enumerate(df_dsn.index.values):
        label_str = category + ' (' + str(df_dsn['Total'][i]) + ')'
        color_val = colormap(float(values_cumsum[i])/total_values)
        legend_handles.append(mpatches.Patch(color=color_val, label=label_str))

    # add legend to chart
    plt.legend(handles=legend_handles,
               loc='lower center',
               ncol=len(df_dsn.index.values),
               bbox_to_anchor=(0., -0.2, 0.95, .1)
               )
    plt.show()


def create_waffle_chart(categories, values, height, width, colormap, value_sign=''):

    # compute the proportion of each category with respect to the total
    total_values = sum(values)
    category_proportions = [(float(value) / total_values) for value in values]

    # compute the total number of tiles
    total_num_tiles = width * height  # total number of tiles
    print('Total number of tiles is', total_num_tiles)

    # compute the number of tiles for each category
    tiles_per_category = [round(proportion * total_num_tiles)
                          for proportion in category_proportions]

    # print out number of tiles per category
    for i, tiles in enumerate(tiles_per_category):
        print(categories[i] + ': ' + str(tiles))

    # initialize the waffle chart as an empty matrix
    waffle_chart = np.zeros((height, width))

    # define indices to loop through waffle chart
    category_index = 0
    tile_index = 0

    # populate the waffle chart
    for col in range(width):
        for row in range(height):
            tile_index += 1

            # if the number of tiles populated for the current category
            # is equal to its corresponding allocated tiles...
            if tile_index > sum(tiles_per_category[0:category_index]):
                # ...proceed to the next category
                category_index += 1

            # set the class value to an integer, which increases with class
            waffle_chart[row, col] = category_index

    # use matshow to display the waffle chart
    colormap = plt.cm.coolwarm
    plt.matshow(waffle_chart, cmap=colormap)
    plt.colorbar()

    # get the axis
    ax = plt.gca()

    # set minor ticks
    ax.set_xticks(np.arange(-.5, (width), 1), minor=True)
    ax.set_yticks(np.arange(-.5, (height), 1), minor=True)

    # add dridlines based on minor ticks
    ax.grid(which='minor', color='w', linestyle='-', linewidth=2)

    plt.xticks([])
    plt.yticks([])

    # compute cumulative sum of individual categories to match color schemes between chart and legend
    values_cumsum = np.cumsum(values)
    total_values = values_cumsum[len(values_cumsum) - 1]

    # create legend
    legend_handles = []
    for i, category in enumerate(categories):
        if value_sign == '%':
            label_str = category + ' (' + str(values[i]) + value_sign + ')'
        else:
            label_str = category + ' (' + value_sign + str(values[i]) + ')'

        color_val = colormap(float(values_cumsum[i])/total_values)
        legend_handles.append(mpatches.Patch(color=color_val, label=label_str))

    # add legend to chart
    plt.legend(
        handles=legend_handles,
        loc='lower center',
        ncol=len(categories),
        bbox_to_anchor=(0., -0.2, 0.95, .1)
    )
    plt.show()


def wordCloud():
    # download file and save as alice_novel.txt
    filename = wget.download(
        'https://s3-api.us-geo.objectstorage.softlayer.net/cf-courses-data/CognitiveClass/DV0101EN/labs/Data_Files/alice_novel.txt')
    maskName = wget.download(
        'https://s3-api.us-geo.objectstorage.softlayer.net/cf-courses-data/CognitiveClass/DV0101EN/labs/Images/alice_mask.png')

    # open the file and read it into a variable alice_novel
    alice_novel = open(filename, 'r').read()
    print('File downloaded and saved!')

    # save mask to alice_mask
    alice_mask = np.array(Image.open(maskName))

    stopwords = set(STOPWORDS)

    # instantiate a word cloud object
    alice_wc = WordCloud(
        background_color='white',
        max_words=2000,
        mask=alice_mask,
        stopwords=stopwords
    )
    stopwords.add('said')

    # generate the word cloud
    alice_wc.generate(alice_novel)

    fig = plt.figure()
    fig.set_figwidth(10)  # set width
    fig.set_figheight(14)  # set height

    # display the word cloud
    plt.imshow(alice_wc, interpolation='bilinear')
    plt.axis('off')
    plt.show()


def wordCloudData(df_canada):
    total_immigration = df_canada['Total'].sum()
    max_words = 90
    word_string = ''

    # Repeat country name based on immigration quantity
    for country in df_canada.index.values:
        # check if country's name is a single-word name
        if len(country.split(' ')) == 1:
            repeat_num_times = int(
                df_canada.loc[country, 'Total']/float(total_immigration)*max_words)
            word_string = word_string + ((country + ' ') * repeat_num_times)

    # create the word cloud
    wordcloud = WordCloud(background_color='white').generate(word_string)

    print('Word cloud created!')

    # display the cloud
    fig = plt.figure()
    fig.set_figwidth(14)
    fig.set_figheight(18)

    plt.imshow(wordcloud, interpolation='bilinear')
    plt.axis('off')
    plt.show()


def regressionPlots_2(df_canada, years):
    df_tot = pd.DataFrame(df_canada[years].sum(axis=0))
    df_tot.index = map(float, df_tot.index)

    df_tot.reset_index(inplace=True)
    df_tot.columns = ['year', 'total']

    plt.figure(figsize=(15, 10))
    # sns.set_style('ticks') # change background to white background
    sns.set_style('whitegrid')

    sns.set(font_scale=1.5)
    ax = sns.regplot(x='year', y='total', data=df_tot,
                     marker='x', scatter_kws={'s': 200})
    ax.set(xlabel='Year', ylabel='Total Immigration')
    ax.set_title('Total Immigration to Canada from 1980 - 2013')
    plt.show()


def canadaMap():
    canada_map = folium.Map(location=[56.130, -106.35],
                            zoom_start=4)  # tiles= Stamen Terrain or Stamen Toner
    # create a feature group
    ontario = folium.map.FeatureGroup()

    # style it
    ontario.add_child(
        folium.CircleMarker(
            [51.25, -85.32], radius=5,
            color='red', fill_color='red'
        )
    )

    # add feature group to the map
    canada_map.add_child(ontario)

    # label the marker
    folium.Marker([51.25, -85.32],
                  popup='Ontario').add_to(canada_map)

    canada_map.save('map.html')


def choroplethMap(df_canada):
    world_map = folium.Map(zoom_start=2, tiles='Mapbox Bright')

    # geojson file
    world_geo = r'world_countries.json'

    # generate choropleth map using the total population of each country
    # to Canada from 1980 to 2013

    world_map.choropleth(
        geo_path=world_geo,
        data=df_canada,
        columns=['Country', 'Total'],
        key_on='feature.properties.name',
        fill_color='Y10rRd',
        legend_name='Immigration to Canada'
    )

    world_map.save('choropleth.html')


def mapsMarkers():
    df_incidents = pd.read_csv(
        'Police_Department_Incidents_-_Previous_Year__2016_.csv')

    print('Dataset downloaded and read into a pandas dataframe!')

    print(df_incidents.head(), df_incidents.shape)

    # get the first 100 crimes
    limit = 100
    df_incidents = df_incidents.iloc[0:limit, :]

    # San Francisco coords
    latitude = 37.77
    longitude = -122.42

    # create a map
    sanfran_map = folium.Map(location=[latitude, longitude], zoom_start=12)

    # incidents = folium.FeatureGroup()

    # for lat, lng, label in zip(df_incidents.Y, df_incidents.X, df_incidents.Category):
    #     incidents.add_child(
    #         folium.CircleMarker(
    #             [lat, lng],
    #             radius=5,
    #             color='yellow',
    #             fill=True,
    #             popup=label,
    #             fill_color='blue',
    #             fill_opacity=0.6
    #         )
    #     )

    # to add pins
    # add pop-up text to each marker on the map
    # latitudes = list(df_incidents.Y)
    # longitudes = list(df_incidents.X)
    # labels = list(df_incidents.Category)

    # for lat, lng, label in zip(latitudes, longitudes, labels):
    #     folium.Marker([lat, lng], popup=label).add_to(sanfran_map)

    # OR

    # Marker cluster
    incidents = MarkerCluster().add_to(sanfran_map)

    # loop through the dataframe and add each data point to the mark cluster
    for lat, lng, label, in zip(df_incidents.Y, df_incidents.X, df_incidents.Category):
        folium.Marker(
            location=[lat, lng],
            icon=None,
            popup=label,
        ).add_to(incidents)

    sanfran_map.add_child(incidents)

    sanfran_map.save('sanfran.html')


if __name__ == "__main__":
    # linePlots(df_canada, years)
    # areaPlots(df_canada)
    # histogramPlots(df_canada)
    # barChart(df_canada, years)
    # pieChart(df_canada)
    # boxPlots(df_canada, years)
    # scatterPlots(df_canada, years)
    # regressionPlots(df_canada, years)
    # bubblePlots(df_canada)
    # waffleChart(df_canada, True)
    wordCloud()
    wordCloudData(df_canada)
    # regressionPlots_2(df_canada, years)
    # canadaMap()
    # mapsMarkers()
